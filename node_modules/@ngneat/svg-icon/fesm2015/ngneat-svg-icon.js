import * as i0 from '@angular/core';
import { InjectionToken, Injectable, Injector, Inject, Component, ChangeDetectionStrategy, ElementRef, Input, NgModule, Optional } from '@angular/core';
import { DOCUMENT } from '@angular/common';

const SVG_ICONS_CONFIG = new InjectionToken('SVG_ICONS_CONFIG');
const SVG_ICONS = new InjectionToken('SVG_ICONS');
const SVG_MISSING_ICON_FALLBACK = new InjectionToken('SVG_MISSING_ICON_FALLBACK');

class SvgIcon {
    constructor(content) {
        this.content = content;
        this.init = false;
    }
}
class SvgIconRegistry {
    constructor(injector, config) {
        this.svgMap = new Map();
        this.document = injector.get(DOCUMENT);
        if (config.icons) {
            this.register(config.icons);
        }
        if (config.missingIconFallback) {
            this.register(config.missingIconFallback);
        }
    }
    getAll() {
        return this.svgMap;
    }
    get(key) {
        const icon = key && this.svgMap.get(key);
        if (!icon) {
            return undefined;
        }
        if (!icon.init) {
            const svg = this.toElement(icon.content);
            svg.setAttribute('fit', '');
            svg.setAttribute('height', '100%');
            svg.setAttribute('width', '100%');
            svg.setAttribute('preserveAspectRatio', 'xMidYMid meet');
            svg.setAttribute('focusable', 'false');
            icon.content = svg.outerHTML;
            icon.init = true;
        }
        return icon.content;
    }
    register(icons) {
        for (const { name, data } of Array.isArray(icons) ? icons : [icons]) {
            if (!this.svgMap.has(name)) {
                this.svgMap.set(name, new SvgIcon(data));
            }
        }
    }
    getSvgElement(name) {
        const content = this.get(name);
        if (!content) {
            return undefined;
        }
        const div = this.document.createElement('div');
        div.innerHTML = content;
        return div.querySelector('svg');
    }
    toElement(content) {
        const div = this.document.createElement('div');
        div.innerHTML = content;
        return div.querySelector('svg');
    }
}
SvgIconRegistry.ɵprov = i0.ɵɵdefineInjectable({ factory: function SvgIconRegistry_Factory() { return new SvgIconRegistry(i0.ɵɵinject(i0.INJECTOR), i0.ɵɵinject(SVG_ICONS_CONFIG)); }, token: SvgIconRegistry, providedIn: "root" });
SvgIconRegistry.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
SvgIconRegistry.ctorParameters = () => [
    { type: Injector },
    { type: undefined, decorators: [{ type: Inject, args: [SVG_ICONS_CONFIG,] }] }
];

class SvgIconComponent {
    constructor(host, registry, config) {
        this.host = host;
        this.registry = registry;
        this.config = config;
        this.mergedConfig = this.createConfig();
        this.element.style.fontSize = this.mergedConfig.sizes[this.mergedConfig.defaultSize || 'md'];
    }
    set key(name) {
        var _a, _b;
        const icon = (_a = this.registry.get(name)) !== null && _a !== void 0 ? _a : this.registry.get((_b = this.config.missingIconFallback) === null || _b === void 0 ? void 0 : _b.name);
        if (icon) {
            this.element.setAttribute('aria-label', `${name}-icon`);
            this.element.classList.remove(`svg-icon-${this.lastKey}`);
            this.lastKey = name;
            this.element.classList.add(`svg-icon-${name}`);
            this.element.innerHTML = icon;
        }
    }
    set size(value) {
        this.element.style.fontSize = this.mergedConfig.sizes[value];
    }
    set width(value) {
        this.element.style.width = coerceCssPixelValue(value);
    }
    set height(value) {
        this.element.style.height = coerceCssPixelValue(value);
    }
    set fontSize(value) {
        this.element.style.fontSize = coerceCssPixelValue(value);
    }
    set color(color) {
        this.element.style.color = color;
    }
    get element() {
        return this.host.nativeElement;
    }
    createConfig() {
        const defaults = {
            sizes: {
                xs: '0.5rem',
                sm: '0.75rem',
                md: '1rem',
                lg: '1.5rem',
                xl: '2rem',
                xxl: '2.5rem',
            },
        };
        return Object.assign(Object.assign({}, defaults), this.config);
    }
}
SvgIconComponent.decorators = [
    { type: Component, args: [{
                selector: 'svg-icon',
                template: '',
                host: {
                    role: 'img',
                    'aria-hidden': 'true',
                },
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [`
      :host {
        display: inline-block;
        fill: currentColor;
        width: 1em;
        height: 1em;
        font-size: 1rem;
      }
    `]
            },] }
];
SvgIconComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: SvgIconRegistry },
    { type: undefined, decorators: [{ type: Inject, args: [SVG_ICONS_CONFIG,] }] }
];
SvgIconComponent.propDecorators = {
    key: [{ type: Input }],
    size: [{ type: Input }],
    width: [{ type: Input }],
    height: [{ type: Input }],
    fontSize: [{ type: Input }],
    color: [{ type: Input }]
};
function coerceCssPixelValue(value) {
    if (value == null) {
        return '';
    }
    return typeof value === 'string' ? value : `${value}px`;
}

class SvgIconsModule {
    constructor(icons, missingIconFallback, service) {
        this.service = service;
        if (icons) {
            this.service.register(icons);
        }
        if (missingIconFallback) {
            this.service.register(missingIconFallback);
        }
    }
    static forRoot(config = {}) {
        return {
            ngModule: SvgIconsModule,
            providers: [
                {
                    provide: SVG_ICONS_CONFIG,
                    useValue: config,
                },
            ],
        };
    }
    static forChild(icons) {
        return {
            ngModule: SvgIconsModule,
            providers: [{ provide: SVG_ICONS, useValue: icons }],
        };
    }
}
SvgIconsModule.decorators = [
    { type: NgModule, args: [{
                declarations: [SvgIconComponent],
                exports: [SvgIconComponent],
            },] }
];
SvgIconsModule.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [SVG_ICONS,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [SVG_MISSING_ICON_FALLBACK,] }] },
    { type: SvgIconRegistry }
];

/**
 * Generated bundle index. Do not edit.
 */

export { SvgIconComponent, SvgIconRegistry, SvgIconsModule, SVG_ICONS_CONFIG as ɵc, SVG_ICONS as ɵd, SVG_MISSING_ICON_FALLBACK as ɵe };
//# sourceMappingURL=ngneat-svg-icon.js.map
