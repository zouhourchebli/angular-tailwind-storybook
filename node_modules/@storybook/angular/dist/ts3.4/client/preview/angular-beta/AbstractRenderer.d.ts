import { Subject } from 'rxjs';
import { ICollection, StoryFnAngularReturnType } from '../types';
import { Parameters } from '../types-6-0';
declare type StoryRenderInfo = {
    storyFnAngular: StoryFnAngularReturnType;
    moduleMetadataSnapshot: string;
};
export declare abstract class AbstractRenderer {
    storyId: string;
    /**
     * Wait and destroy the platform
     */
    static resetPlatformBrowserDynamic(): Promise<void>;
    /**
     * Reset compiled components because we often want to compile the same component with
     * more than one NgModule.
     */
    protected static resetCompiledComponents: () => Promise<void>;
    protected previousStoryRenderInfo: StoryRenderInfo;
    protected storyProps$: Subject<ICollection | undefined>;
    constructor(storyId: string);
    protected abstract beforeFullRender(): Promise<void>;
    /**
     * Bootstrap main angular module with main component or send only new `props` with storyProps$
     *
     * @param storyFnAngular {StoryFnAngularReturnType}
     * @param forced {boolean} If :
     * - true render will only use the StoryFn `props' in storyProps observable that will update sotry's component/template properties. Improves performance without reloading the whole module&component if props changes
     * - false fully recharges or initializes angular module & component
     * @param parameters {Parameters}
     */
    render({ storyFnAngular, forced, parameters, targetDOMNode, }: {
        storyFnAngular: StoryFnAngularReturnType;
        forced: boolean;
        parameters: Parameters;
        targetDOMNode: HTMLElement;
    }): Promise<void>;
    protected initAngularRootElement(targetDOMNode: HTMLElement, targetSelector: string): void;
    private fullRendererRequired;
}
export {};
